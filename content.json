{"meta":{"title":"advacing-oozy","subtitle":null,"description":null,"author":"chao_shi","url":"http://sccando.github.io"},"pages":[],"posts":[{"title":"VUE 初识","slug":"vue初识","date":"2017-09-19T07:31:25.922Z","updated":"2017-09-19T09:01:18.862Z","comments":true,"path":"2017/09/19/vue初识/","link":"","permalink":"http://sccando.github.io/2017/09/19/vue初识/","excerpt":"","text":"最近开始学习VUE,在学VUE之前有必要先提一个概念MVVM，即Model-View-ViewModel。M：封装了核心数据、逻辑和功能的计算关系的模型；V：视图（表现）；VM：包含所有由UI特定的接口和属性，并由一个VM的视图的绑定属性，并可获得二者之间的松散耦合。 MVVM模式主要目的是分离视图（View）和模型（Model），优点如下：1、低耦合。视图可以独立于Model变化和修改，一个ViewModel可以绑定到不同的View上，当View变化时，Model可以不变，当Model变化时，View也可以不变。2、可重用性。可以把一些视图逻辑放在一个ViewModel里面，让很多View重用这段视图逻辑。3、独立开发。开发人员可以专注于业务逻辑和数据的开发（ViewModel），设计人员可以专注于页面设计。4、可测试。界面素来比较难以测试，而现在测试可以针对ViewModel来写。 Vue.js 专注于 MVVM 模型的 ViewModel 层。它通过双向数据绑定把 View 层和 Model 层连接了起来。Vue.js和其他库相比是一个小而美的库，作者的主要目的是通过一个尽量简单的 API 产生可反映的数据绑定和可组合的视图组件。 如何使用Vue.js1、引入Vue.js2、创建Vue实例3、实例挂载option，option中固定的属性有：el、data、methods、computed等。 概念概述1、ViewModelvar vm = new Vue({/* option */}) ViewModel是一个对象，同步模型和视图，在Vue.js中，就是实例化的Vue的构造器或者是它的子类。 2、Viewvm.$el View是实际HMTL/DOM。使用Vue时，除了自定义的指令，你几乎不会触碰到DOM的操作，当数据更新后视图的更新将会自动触发。 3、Modelvm.$data Model在Vue.js中是简单的js对象、数据对象，你能够操控他们的属性和视图模型。","categories":[],"tags":[]},{"title":"JS 之 常用设计模式","slug":"JS之面向对象","date":"2017-09-14T13:09:50.457Z","updated":"2017-09-15T06:38:43.776Z","comments":true,"path":"2017/09/14/JS之面向对象/","link":"","permalink":"http://sccando.github.io/2017/09/14/JS之面向对象/","excerpt":"","text":"JS中，万事万物皆对象！ 面向对象是按照对象、类、实例三层体系架构实现的，js把所有的东西按照特征分成了很多的大类小类，我们要研究其中的某一个类，只需要研究里面的一个实例即可，这种研究的方式就叫面向对象。 是不是有些懵圈？接下来我将会拿“乐器”来辅助理解什么是对象、类、实例：1、对象——乐器。泛指，具体可理解为无序属性的集合，其属性可以包含基本值、对象或函数。2、类——西洋乐器、民族乐器。对象的具体细分。3、实例——钢琴、古筝。某个类中的具体事物。 设计模式一、单例模式/单子模式/单体模式 把描述的同一个事物（或同一个对象）放在一个内存空间，起到分组的作用。 软件设计中较为简单，最为常用的一种设计模式。 针对模块开发。项目中开发的模块比较多，多人协作，每个人负责一个模块，最终把代码合并到一起时，即使对象的属性名相同也不会产生冲突。 var fly = { name:&apos;飞机&apos;, type:&apos;飞机&apos;, fn:function(){ console.log(123) } } var bus = { name:&apos;大巴&apos;, type:&apos;大巴&apos;, fn:function(){ console.log(134) } } 高级单例模式var obj = (function(){ function fn(){}; function pre(){}; function next(){}; return { fn: fn, pre: pre, next: next } })() 缺点：使用同个接口创建对象，会产生大量的重复代码，为了解决这个问题，开发了工厂模式。 二、工厂模式 把实现一个功能的代码放到一个函数里面，减少冗余的代码（实质上就是一个封装函数 ） function student(name,age){ var obj = { name: name, age: age } return obj; } var p1 = student(&apos;name1&apos;,20); var p2 = student(&apos;name2&apos;,18); 优点：高内聚低耦合——减少页面中的重复代码，提高代码的利用率缺点：无法识别对象的类型，因为全部都是Object，不像Date、Array等。因此出现了构造函数模式。 三、构造函数ECMAScript中构造函数可以创建特定类型的对象，类似于Array、Date等原生JS的对象。 1、一般约定将函数名首字母大写；2、不用手动创建对象，用this；3、没有return，直接会返回一个对象作为这个类的实例；4、执行的时候要用new。 function Person(name,age){ // 执行之前，浏览器默认创建一个对象 this.name = name, // 给当前实例添加私有属性 this.age = age // 默认将这个对象返回 } Person.prototype.say = function(){ console.log(this.name,this.age) } // 此时的s1、s2就是Person的实例 s1、s2是对象 // 构造函数模式，执行它的返回值就是这个类的实例，每一个实例都是一个独立的个体。 // 构造函数中的this指的是当前实例 var s1 = new Person(&apos;zs&apos;,18); var s2 = new Person(&apos;ls&apos;,20); s1.say(); function CreatePerson(name,age){ this.name = name; this.age = age; return { info : &apos;hahaha&apos;} // 返回的就是引用数据类型 return 123 // 基本数据类型对实例无影响 } var person1 = new CreatePerson(&apos;zs&apos;,10); console.log(person1) // info:&apos;hahaha&apos; 实例化的过程 1、也和普通函数执行一样，创建一个私有作用域，进行形参赋值和预解释;2、预解释完成后，浏览器会默认的在私有作用域中创建一个对象，而且函数的this指向这个对象；3、和普通函数一样，代码从上往下执行（作用域链）；4、代码执行完成后，会默认的把第二步中创建的对象返回；5、构造函数执行时，如果不需传参，后面的小括号可加可不加，没区别；6、函数中，如手动返回的是基本数据类型，对最后的实例没有影响，如果返回的是引用数据类型，会把默认返回的实例覆盖掉。通过构造函数创建出来的实例都是相互独立的个体，互不影响，而在构造函数中的this.XXX相当于给当前的实例增加了属于自己的私有属性。 工厂模式和构造函数模式对比： 1、工厂模式，return出手工创建的对象；构造函数，默认创建一个对象，同时默认将这个对象返回。2、构造函数，直接将属性和方法赋值给了this对象。3、工厂模式，是普通函数执行；构造函数，通过new来执行，将其返回作为这个类的实例。4、构造函数，执行时形成一个私有作用域-&gt; 形参赋值 -&gt; 预解释 -&gt; 代码从上至下执行。5、工厂函数，返回的就是对象；构造函数，能够识别对象的具体类型。 构造函数缺点：每次创建实例时都要创建一次方法（理论上每次创建对象时的属性均不同，而对象的方法是相同的），然而创建两次完全相同的方法是没有必要的，因此，我们可以将函数移到对象外面。 四、原型模式 我们创建的每个函数都有prototype（原型）属性，这个属性是一个指针，指向一个对象，而这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法。 function Fn(){}; Fn.prototype.name = &apos;s&apos;; Fn.prototype.age = 18; Fn.prototype.say = function(){ console.log(this.name + this.age); } var p1 = new Fn(); var p2 = new Fn(); 优点：可以让所有对象实例共享它所包含的属性及方法。缺点：它省略了构造函数传递初始化参数这一环节，结果所有实例在默认情况下都取得了相同的属性值，这样非常不方便，但这还不是原型的最大问题，原型模式的最大问题在于共享的本性所导致的，由于共享，如果一个实例修改了引用，另一个也随之更改了引用。 因此，我们通常不单独使用原型，而是结合原型模式与构造函数模式。 五、混合模式（原型模式+构造函数模式） 混合模式中构造函数用于定义实例属性，而原型模式用于定义方法和共享属性。每个实例都会有自己的一份实例属性，同时又有共享方法，最大限度的节省了内存。 这种模式还支持传递初始参数，优点甚多。 这种模式在ECMAScript中是使用最广泛、认同度最高的一种创建自定义对象的方法。 function Fn(name,age){ this.name = name; this.age = age; } Fn.prototype.say = function(){ console.log(this.name + this.age); } var p1 = new Fn(); var p2 = new Fn();","categories":[],"tags":[]},{"title":"浅谈响应式布局","slug":"浅谈响应式布局","date":"2017-09-13T06:41:21.433Z","updated":"2017-09-18T16:48:28.590Z","comments":true,"path":"2017/09/13/浅谈响应式布局/","link":"","permalink":"http://sccando.github.io/2017/09/13/浅谈响应式布局/","excerpt":"","text":"响应式布局，简言之：一个网站可以根据不同设备环境自动响应及调整，而不是为每个终端都做一个特定的版本。此概念为解决移动互联网浏览而诞生，是一种对于设计的全新思维模式，可以为不同终端的用户提供更加舒适的界面和更好的用户体验，而且随着大屏幕移动设备的普及，实为大势所趋！ 优势:1、多终端视觉和操作体验风格统一2、兼容当前及未来新设备3、节约开发及维护成本 不足:1、兼容各种设备工作量大，效率低下2、代码累赘，会出现隐藏无用的元素，加载时间加长 @media （媒介查询）","categories":[],"tags":[]}]}